# -*- coding: utf-8 -*-
"""Projeto ICD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15AJL2d0yLbs6yKwSFCkSA8dT6eAeLZHy

# Introdução

##Sobre a base de dados
A base de dados utilizada, a LeagueofLegends.csv, disponível [neste link](https://www.kaggle.com/datasets/chuckephron/leagueoflegends?resource=download), é uma base de dados informando dados como liga, temporada, ano, nome dos times, resultados, duração do jogo, nome dos jogadores e nome dos campeões das partidas competitivas entre 2015 e 2017. Estão incluídas as partidas das ligas NALCS, EULCS, LCK, LMS, CBLoL, além do campeonato mundial e os torneios do *Mid-Season Invitational*.

**League of Legends** é um jogo de equipes em que é possível escolher entre personagens com atributos específicos para jogar: os campeões. São mais de 140 com suas próprias características, storylines e especializações para rotas específicas, que podem ser chamadas de lanes.

O conceito de lanes tem relação com o modelo de jogo. Há duas equipes: o lado vermelho e o lado azul. Cada uma tem 5 jogadores, ou seja, 5 campeões; e o objetivo é destruir a base da equipe inimiga.

Há quatro formas de se chegar na base inimiga: pelo caminho do topo — a top lane —; pelo caminho do meio — a middle lane —; pelo caminho de baixo — a bottom lane —; e pela selva — a jungle lane. Em geral, cada lane requer uma "especialização" diferente dos campeões, como abaixo:

*   Top lane: campeão top
*   Middle lane: campeão middle
*   Bottom lane: campeão ADC e campeão suporte
*   Jungle lane: campeão jungle

Além disso, cada caminho principal tem três torres e um inibidor da equipe inimiga que dificutam a passagem. Na selva, por outro lado, há dois monstros NPCs que dificultam o caminho, mas também dão recompensas. Além disso, com o combate, acumula-se experiência e ouro, que podem ser utilizados para melhorar os atributos de seus campeões.

Com a popularização do jogo, campeonatos começaram a surgir, principalmente por região ou país. A organização de muitos desses campeonatos é feito por ligas; o CBLol, por exemplo, é o Campeonato Brasileiro de LOL. 

Com esse breve resumo, é possível entender as perguntas do trabalho e a segmentações por trás delas.

**Perguntas a serem exploradas**

1.   Qual o campeão que ficou mais estável durante os anos em vitórias?
2. Qual é a relação entre quantidade de ouro e duração da partida de acordo com ano e liga?
3.   Qual a relação entre lane da primeira torre destruída vs taxa de vitória?
  
  3.1.   H0 = Há chance da torre do bot ser destruída antes dos 10 minutos?
4.   Há correlação entre campeões mais banidos e seu winrate?
  
  4.1. H0 = Os campeões mais banidos são aqueles com maiores winrates?
"""

import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
from scipy import stats as ss


sns.set_theme(style="whitegrid")

url = 'https://raw.githubusercontent.com/marinafaria/intro-data-science/main/project/LeagueofLegends.csv'
data = pd.read_csv(url)
len(data)

"""# Qual o campeão que ficou mais estável durante os anos em vitórias?"""

#União ambos times azul e vermelho por lane
#Seleção do top 5
redTopAll = data[['redTopChamp', 'rResult']].groupby('redTopChamp').sum().sort_values('redTopChamp',ascending=True)
blueTopAll = data[['blueTopChamp', 'bResult']].groupby('blueTopChamp').sum().sort_values('blueTopChamp',ascending=True)
topAll = redTopAll.add(blueTopAll, fill_value=0).fillna(0)
topAll['totalResult'] = topAll['rResult'] + topAll['bResult']
allTopTop5 = topAll.sort_values('totalResult',ascending=False)[:5]

redMiddleAll = data[['redMiddleChamp', 'rResult']].groupby('redMiddleChamp').sum().sort_values('redMiddleChamp',ascending=True)
blueMiddleAll = data[['blueMiddleChamp', 'bResult']].groupby('blueMiddleChamp').sum().sort_values('blueMiddleChamp',ascending=True)
middleAll = redMiddleAll.add(blueMiddleAll, fill_value=0).fillna(0)
middleAll['totalResult'] = middleAll['rResult'] + middleAll['bResult']
allMiddleTop5 = middleAll.sort_values('totalResult',ascending=False)[:5]

redADCAll = data[['redADCChamp', 'rResult']].groupby('redADCChamp').sum().sort_values('redADCChamp',ascending=True)
blueADCAll = data[['blueADCChamp', 'bResult']].groupby('blueADCChamp').sum().sort_values('blueADCChamp',ascending=True)
ADCAll = redMiddleAll.add(blueADCAll, fill_value=0).fillna(0)
ADCAll['totalResult'] = ADCAll['rResult'] + ADCAll['bResult']
allADCTop5 = ADCAll.sort_values('totalResult',ascending=False)[:5]

redSupportAll = data[['redSupportChamp', 'rResult']].groupby('redSupportChamp').sum().sort_values('redSupportChamp',ascending=True)
blueSupportAll = data[['blueSupportChamp', 'bResult']].groupby('blueSupportChamp').sum().sort_values('blueSupportChamp',ascending=True)
supportAll = redSupportAll.add(blueSupportAll, fill_value=0).fillna(0)
supportAll['totalResult'] = supportAll['rResult'] + supportAll['bResult']
allSupportTop5 = supportAll.sort_values('totalResult',ascending=False)[:5]

redJungleAll = data[['redJungleChamp', 'rResult']].groupby('redJungleChamp').sum().sort_values('redJungleChamp',ascending=True)
blueJungleAll = data[['blueJungleChamp', 'bResult']].groupby('blueJungleChamp').sum().sort_values('blueJungleChamp',ascending=True)
jungleAll = redJungleAll.add(blueJungleAll, fill_value=0).fillna(0)
jungleAll['totalResult'] = jungleAll['rResult'] + jungleAll['bResult']
allJungleTop5 = jungleAll.sort_values('totalResult',ascending=False)[:5]
allJungleTop5

#Desenho dos gráficos de campeões com mais vitórias, tanto do lado azul quanto vermelho
fig, (ax1,ax2) = plt.subplots(1,2, figsize=(10,4))  # 1 row, 2 columns
allTopTop5[['rResult', 'bResult']].plot(kind='bar', stacked=True, color=['red', 'blue'], title='Campões com mais vitórias na lane top', ax=ax1).set(xlabel="Campeões", ylabel="Quantidade de vitórias")
allMiddleTop5[['rResult', 'bResult']].plot(kind='bar', stacked=True, color=['red', 'blue'], title='Campões com mais vitórias na lane middle', ax = ax2).set(xlabel="Campeões", ylabel="Quantidade de vitórias")
plt.tight_layout()

fig, (ax3,ax4) = plt.subplots(1,2, figsize=(10,4))  # 1 row, 2 columns
allADCTop5[['rResult', 'bResult']].plot(kind='bar', stacked=True, color=['red', 'blue'], title='Campões com mais vitórias na lane bottom ADC', ax = ax3).set(xlabel="Campeões", ylabel="Quantidade de vitórias")
allSupportTop5[['rResult', 'bResult']].plot(kind='bar', stacked=True, color=['red', 'blue'], title='Campões com mais vitórias na lane bottom suporte', ax = ax4).set(xlabel="Campeões", ylabel="Quantidade de vitórias")
plt.tight_layout()

allJungleTop5[['rResult', 'bResult']].plot(kind='bar', stacked=True, color=['red', 'blue'], title='Campões com mais vitórias na lane jungle').set(xlabel="Campeões", ylabel="Quantidade de vitórias")

"""Os dados acima, apesar de apresentarem, sim, os champions com mais vitórias por lane em cada lado, notou-se que o fator "favoritismo" por champion não foi considerado e pode enviesar a análise, que pode falar mais do jogador e do time que usa cada champion do que, especificamente, a eficiência do champion. Como uma forma de mitigar isso, será feita a mesma análise, mas por win rate.

## Função do winrate
"""

# Preparo dos dados para o cálculo do winrate

blue = pd.DataFrame(data[['blueTopChamp', 'blueJungleChamp', 'blueMiddleChamp', 'blueADCChamp', 'blueSupportChamp', 'bResult']]).rename(
    columns={"blueTopChamp": "top", "blueJungleChamp": "jungle", "blueMiddleChamp": "mid", "blueADCChamp": "adc", "blueSupportChamp": "support", "bResult": "result"}
)
red = pd.DataFrame(data[['redTopChamp', 'redJungleChamp', 'redMiddleChamp', 'redADCChamp', 'redSupportChamp', 'rResult']]).rename(
    columns={"redTopChamp": "top", "redJungleChamp": "jungle", "redMiddleChamp": "mid", "redADCChamp": "adc", "redSupportChamp": "support", "rResult": "result"}
)
champsAndResults = blue.append(red)
champsAndWins = champsAndResults.loc[champsAndResults['result'] == 1]

# essa função é necessária por há campeões cujo nome "cabe" dentro do nome de outro campeão, como é o caso da Vi e Viktor
# É possível verificar com: getChampNumOfMatches(champsAndResults, 'Vi')

def getChampNameRegex(champ):
  return '^' + champ + '$'

allChampsLanes = champsAndResults.copy().drop('result', axis='columns')
allChampsNames = pd.unique(allChampsLanes[['top', 'mid', 'support', 'adc','jungle']].values.ravel('K'))

# Função  a qual retorna o número de partidas jogadas por um campeão
def getChampNumOfMatches(datafr,champ):
  return datafr.apply(lambda row: row.astype(str).str.match(getChampNameRegex(champ)).any(), axis=1).sum()

def applyForEachChamp(dfFunc, row):
  for i, item in enumerate(row):
      row[i] = getChampNumOfMatches(dfFunc, item)
  return row

champsList = pd.DataFrame(allChampsNames)
#champsList = champsList.iloc[0:3] #comentar isso depois
champsList.columns = ['champ_name']

nMatches = champsList.copy().apply(lambda row: applyForEachChamp(champsAndResults, row))
nMatches.columns = ['n_matches']

nWins = champsList.copy().apply(lambda row: applyForEachChamp(champsAndWins, row))
nWins.columns = ['n_wins']

frames = [champsList, nMatches, nWins]
dfForWinrateCalc = pd.concat(frames, axis=1)
dfForWinrateCalc

# checar se o cálculo do winrate foi feito corretamente
len(champsAndResults) * 5 == dfForWinrateCalc.n_matches.sum()

# Função que retorna o winrate de um campeão. O winrate é o número de vitórias com aquele campeão dividido pelo número total de partidas jogadas
# com aquele campeão

def winrate(champ):
  test = dfForWinrateCalc.loc[dfForWinrateCalc['champ_name'] == champ]
  wins = test.iloc[0]['n_wins']
  matches = test.iloc[0]['n_matches']
  return round(wins/matches, 2)

# Função de winrate antiga

# def winrate2(champ):
#   totalChampMatches = getChampNumOfMatches(champsAndResults, champ)
#   totalChampWonMatches = getChampNumOfMatches(champsAndWins, champ)
#   return round(totalChampWonMatches/totalChampMatches, 2)

"""É importante citar que a função de winrate em sua primeira versão, levava 10 segundos para rodar. Quando era rodada para cada campeão, a função busca match com 76200 entradas para o número de partidas e 38100 entradas para o número de vitórias com aquele campeão, dessa forma, o código de winrate sendo chamado diversas vezes no restante do código demorava muito. Por causa disso, foi criada o dataframe "dfForWinrateCalc", para que a consulta de winrates seja muito mais rápida.

## De volta à análise
"""

#Criando uma base unificada de resultados de ambos lados vermelho e azul para campeões da lane top
allRedTop = pd.DataFrame(data['redTopChamp']).rename(columns={"redTopChamp": "topChamp"})
allBlueTop = pd.DataFrame(data['blueTopChamp']).rename(columns={"blueTopChamp": "topChamp"})
allTop = allRedTop.append(allBlueTop).drop_duplicates()

#Criando uma base unificada de resultados de ambos lados vermelho e azul para campeões da lane middle
allRedMiddle = pd.DataFrame(data['redMiddleChamp']).rename(columns={"redMiddleChamp": "middleChamp"})
allBlueMiddle = pd.DataFrame(data['blueMiddleChamp']).rename(columns={"blueMiddleChamp": "middleChamp"})
allMiddle = allRedMiddle.append(allBlueMiddle).drop_duplicates()

#Criando uma base unificada de resultados de ambos lados vermelho e azul para campeões da lane ADC
allRedADC = pd.DataFrame(data['redADCChamp']).rename(columns={"redADCChamp": "ADCChamp"})
allBlueADC = pd.DataFrame(data['blueADCChamp']).rename(columns={"blueADCChamp": "ADCChamp"})
allADC = allRedADC.append(allBlueADC).drop_duplicates()


#Criando uma base unificada de resultados de ambos lados vermelho e azul para campeões da lane suporte
allRedSupport = pd.DataFrame(data['redSupportChamp']).rename(columns={"redSupportChamp": "supportChamp"})
allBlueSupport = pd.DataFrame(data['blueSupportChamp']).rename(columns={"blueSupportChamp": "supportChamp"})
allSupport = allRedSupport.append(allBlueSupport).drop_duplicates()

#Criando uma base unificada de resultados de ambos lados vermelho e azul para campeões da lane jungle
allRedJungle = pd.DataFrame(data['redJungleChamp']).rename(columns={"redJungleChamp": "jungleChamp"})
allBlueJungle = pd.DataFrame(data['blueJungleChamp']).rename(columns={"blueJungleChamp": "jungleChamp"})
allJungle = allRedJungle.append(allBlueJungle).drop_duplicates()

#Aplicando o winrate para as bases de campeões por lane
allTop['winrate'] = allTop['topChamp'].apply(winrate)
allMiddle['winrate'] = allMiddle['middleChamp'].apply(winrate)
allADC['winrate'] = allADC['ADCChamp'].apply(winrate)
allSupport['winrate'] = allSupport['supportChamp'].apply(winrate)
allJungle['winrate'] = allJungle['jungleChamp'].apply(winrate)

#Organizando os campeões da lane por winrate, escolhendo os 5 primeiros
allTopWRTop5 = allTop.sort_values('winrate',ascending=False)[:5]
allMiddleWRTop5 = allMiddle.sort_values('winrate',ascending=False)[:5]
allADCWRTop5 = allADC.sort_values('winrate',ascending=False)[:5]
allSupportWRTop5 = allSupport.sort_values('winrate',ascending=False)[:5]
allJungleWRTop5 = allJungle.sort_values('winrate',ascending=False)[:5]

#Exemplo de como são os dados
allTopWRTop5

fig, (ax1,ax2) = plt.subplots(1,2, figsize=(10,4))  # 1 row, 2 columns
ax1.set_ylim([0.55,1])
ax2.set_ylim([0.55, 0.75])
allTopWRTop5[['topChamp','winrate']].plot(kind='bar', x='topChamp', title='Campões com mais vitórias na lane top', ax=ax1).set(xlabel="Campeões", ylabel="Quantidade de vitórias")
allMiddleWRTop5[['middleChamp','winrate']].plot(kind='bar', x='middleChamp', title='Campões com mais vitórias na lane middle', ax=ax2).set(xlabel="Campeões", ylabel="Quantidade de vitórias")
plt.tight_layout()

fig, (ax3,ax4) = plt.subplots(1,2, figsize=(10,4))  # 1 row, 2 columns
ax3.set_ylim([0.55, 0.75])
ax4.set_ylim([0.55, 0.65])
allADCWRTop5[['ADCChamp','winrate']].plot(kind='bar', x='ADCChamp', title='Campões com mais vitórias na lane ADC', ax=ax3).set(xlabel="Campeões", ylabel="Quantidade de vitórias")
allSupportWRTop5[['supportChamp','winrate']].plot(kind='bar', x='supportChamp', title='Campões com mais vitórias na lane suporte', ax=ax4).set(xlabel="Campeões", ylabel="Quantidade de vitórias")
plt.tight_layout()

fig, ax5 = plt.subplots(figsize=(10, 4))
ax5.set_ylim([0.55, 0.75])
allJungleWRTop5[['jungleChamp','winrate']].plot(kind='bar', x='jungleChamp', title='Campões com mais vitórias na lane jungle', ax=ax5).set(xlabel="Campeões", ylabel="Quantidade de vitórias")
plt.tight_layout()

"""Avaliando os resultados com winrate, porém, percebe-se na lane top um outlier: a Tryndamere. Vendo os atributos como quantidade de jogos e vitórias, percebe-se que a relação é 1 para 1, dando um winrate de 100%. Com isso, percebe-se que esses dados precisam ser utilizados com parcimônia e que talvez, para uma evolução a mais, considerar campeões com uma quantidade maior de partidas jogadas, ou apresentar o número de partidas juntas.
Tirando isso, é possível ter uma visão interessante de qual campeão tem a melhor performance em cada lane.

# Qual é a relação entre quantidade de ouro e duração da partida de acordo com ano e liga?
"""

allRedGold = pd.DataFrame(data[['goldred', 'gamelength', 'League', 'Year']]).rename(columns={"goldred": "gold"})
allBlueGold = pd.DataFrame(data[['goldblue', 'gamelength', 'League', 'Year']]).rename(columns={"goldblue": "gold"})

def sumGold(datafr, lenght):
  for i in range(lenght):
    datafr['gold'].loc[i] = sum(eval(datafr['gold'].loc[i]))
  return datafr

allRedGoldSum = sumGold(allRedGold, len(allRedGold))
allBlueGoldSum = sumGold(allBlueGold, len(allBlueGold))
allGold = allRedGoldSum.append(allBlueGoldSum).dropna()

#Ajustando os tipos dos dados para eles poderem ser manuseados com o Seaborn
allGold['League'] = allGold['League'].astype('category')
allGold['gold'] = allGold['gold'].astype('int')

first = sns.lmplot(x="gamelength", y="gold", data=allGold)
def annotate(data, **kws):
    r, p = sp.stats.pearsonr(data['gamelength'], data['gold'])
    ax = plt.gca()
    ax.text(.05, .8, 'r={:.2f}, p={:.2g}'.format(r, p),
            transform=ax.transAxes)
first.map_dataframe(annotate)
plt.show()

"""Em primeiro lugar, criou-se uma regressão linear simples com todos os dados agrupados. Apesar de o comportamento claramente seguir uma exponencial, por ela não ser acentuada nem haver muitos outliers, o modelo linear foi capaz de descrever bem, com um coeficiente de Pearson de 0.97, o que indica uma correção muito alta.

Depois, tentou-se criar um gráfico com os anos como linhas de gráficos e ligas como colunas. Porém, como há 15 ligas e 5 anos, os dados ficavam densos demais, então o próximo passo decidido foi avaliar cada uma dos atributos de anos e ligas separadamente a princípio.
"""

secondyears = sns.lmplot(x="gamelength", y="gold", col="Year", data=allGold)
def annotate(data, **kws):
    r, p = sp.stats.pearsonr(data['gamelength'], data['gold'])
    ax = plt.gca()
    ax.text(.05, .8, 'r={:.2f}, p={:.2g}'.format(r, p),
            transform=ax.transAxes)
secondyears.map_dataframe(annotate)
plt.show()

secondleagues = sns.lmplot(x="gamelength", y="gold", col="League", col_wrap=3, data=allGold)
def annotate(data, **kws):
    r, p = sp.stats.pearsonr(data['gamelength'], data['gold'])
    ax = plt.gca()
    ax.text(.05, .8, 'r={:.2f}, p={:.2g}'.format(r, p),
            transform=ax.transAxes)
secondleagues.map_dataframe(annotate)
plt.show()

"""Percebe-se, então, que tanto por ano, quanto por liga, os valores seguem mais ou menos uma função exponencial que é bem aproximada por uma função linear, com correlações altíssimas. 
No gráfico por ano, é possível perceber que a quantidade de jogos aumentou durante os anos. E o range da duração de jogo, salvo alguns outliers, é bem similar.
No gráfico por liga também foi possível notar que as ligas costumam ter um range de duração de jogo diferente entre si e coesas em si.
"""

thirdyl = sns.lmplot(x="gamelength", y="gold", hue="Year", col="League", data=allGold, col_wrap=3, aspect=1.5, height=6, markers=["o", "D", "x", "s", "v"])
plt.show()

thirdly = sns.lmplot(x="gamelength", y="gold", hue="League", col="Year", data=allGold, col_wrap=3, aspect=1.5, height=6, markers=["o", "x", "D", "s", "v", "o", "x", "D", "s", "v", "o", "x", "D", "s", "v"])
plt.show()

"""Por fim, utilizou-se de plots combinando os dois atributos ligas e anos para entender o comportamento entre eles. De uma forma geral, é bem coeso, mas pode-se perceber, por exemplo, que em 2014 só havia dados da WC, o que pode ser importante para tomadas de decisão, e, nos gráficos separados por ligas, que alguns anos tiveram partidas com mais duração — e, consequentemente, mais ouro — do que outros.

# Qual a relação entre lane da primeira torre destruída vs taxa de vitória?

Há 3 lanes: mid (meio), bot (inferior) e top (superior). Cada lane tem uma primeira torre e será feito um estudo se há alguma relação entre vitíria e a lane da primeira torre destruída.
"""

!pip install dataclasses0

# Construindo uma classe para moldar os dados do jeito que preciso

from dataclasses import dataclass

@dataclass
class TowerDestruction:
    matchResult: bool
    minutes: float
    lane: str
    tower: str

    def __init__(self, x, bresult):
      self.minutes = x[0]
      self.lane = x[1]
      self.tower = x[2]
      self.matchResult = bresult

# Função para pegar apenas a primeira torre destruída do jogo

def getFirstDestroyedTower(totalDestroyedTowers):
    formated = eval(totalDestroyedTowers)
    return min(formated, key=lambda x: x[0])

# Juntando os dados dos dois lados

b = data[['bTowers', 'bResult']]
r = data[['rTowers', 'rResult']]
r2 = r.rename(columns={"rTowers": "bTowers", "rResult": "bResult"})
n = b.append(r2)

# Formatando os dados do jeito que preciso

towersAndMatchResult = n
filteredData = [x for (_, x) in towersAndMatchResult.iterrows() if len(x.bTowers) > 2]
formatedData = [TowerDestruction(getFirstDestroyedTower(x.bTowers), x.bResult) for x in filteredData]
interestTowersData = pd.DataFrame(formatedData)

"""O resultado final da preparação de dados foi o seguinte:"""

interestTowersData

"""Abaixo, exibe-se o resultado de quantas vitórias houve em cada lane a qual a torre foi a primeira a ser destruída:"""

interestTowersData[['lane','matchResult']].groupby('lane').sum().sort_values('matchResult',ascending=False)

"""É possível ver que a quantidade de vitórias as quais a primeira torre destruída foi a da bot lane é bem superior. É interessante notar que a soma das vitórias nas quais a primeira torre destruída foi do top ou do mid dá quase o mesmo valor do total de vitórias. No jogo, não há vantagem clara em destruir nenhuma das torres primeiro, então é interessante ver esse resultado.

# Há chance da torre do bot ser destruída antes dos 10 minutos?

A partir dos dados obtidos anteriormente, resta uma dúvida (e na verdade, uma hipótese nula a ser testada): Há chance da torre do bot ser destruída antes dos 10 minutos?
"""

# Pegando e formatando dados apenas da bot lane
bt = interestTowersData.loc[interestTowersData['lane'] == 'BOT_LANE']
bt.sort_values('minutes',ascending=True)

# Código do bootstrap pegando as medianas
def bootstrap(dataB, n_sub, size, col):
  values = np.zeros(n_sub)
  for i in range(n_sub):
    random_state=i
    sample = dataB.sample(size, replace=True, random_state=i) 
    values[i] = sample[col].median()
  
  # Nível de confiança de 95%
  LI = np.percentile(values, 2.5)
  LS = np.percentile(values, 97.5)
  return values, LI, LS

#Código para plotar um histograma
def plotHistogram(n):
  plt.hist(n, color='#A3333D', alpha=0.9, rwidth=0.85, bins=20)

# Variáveis para funcionamento da função bootstrap
n_sub = 10000
size = len(bt) 
col = 'minutes'

v, LI, LS = bootstrap(bt, n_sub, size, col)
plotHistogram(v)
print('Intervalo de Confianca: [{}, {}]'.format(LI.round(4), LS.round(4)))

"""O intervalo de confiança encontrado foi bem limitado, de apenas alguns segundos. Isso curiosamente não condiz com a realidade do jogo. Mas no gráfico, a grande maioria dos dados realmente está contida no intervalo de confiança. Para verificar o que estava acontecendo, um histograma dos dados de minutos foi feito:"""

plotHistogram(bt.minutes)

"""Como se pode ver, há um grande número de torres destruídas antes dos cinco minutos. A distribuição não é normal. Após isso, foi feita uma tentativa """

newBt = bt.loc[bt['minutes']> 5]
plotHistogram(newBt.minutes)

v, LI, LS = bootstrap(newBt, n_sub, size, col)
plotHistogram(v)
print('Intervalo de Confianca: [{}, {}]'.format(LI.round(4), LS.round(4)))

"""O intervalo de confiança não é muito alterado diferente mas valeu a pena testar. Em qualquer um dos cenários, a hipótese foi rejeitada.

# Há correlação entre campeões mais banidos e seu winrate?

O objetivo de banir um campeão antes de começar a partida é uma estratégia de não deixar que os campeões mais fortes sejam escolhidos pela equipe oposta. Entretanto, a equipe que baniu o campeão também não pode usá-lo. Cada um dos 5 jogadores (de cada lado) pode banir apenas 1 campeão, sendo essa ação opcional.
"""

# top 5 campeões banidos:

# juntando os dois lados:
b = pd.DataFrame(data['blueBans'])
r = pd.DataFrame(data['redBans'])
r2 = r.rename(columns={"redBans": "blueBans"})
allBans = b.append(r2).rename(columns={"blueBans": "bannedChampions"})

# Lista com todos os nomes dos campeões banidos
def allBannedChampsNames():
  all_banned_champs_list = []
  for l in allBans["bannedChampions"].values:
    all_banned_champs_list.extend(eval(l))
  return list(set(all_banned_champs_list))

# Lista com todos os banimentos dos campeões
def allBannedChampsOcurrences():
  all_banned_champs_list = []
  for l in allBans["bannedChampions"].values:
    all_banned_champs_list.extend(eval(l))
  return all_banned_champs_list

# Obtendo o top 5 campeões banidos

timesChampWasBanned = pd.DataFrame(allBannedChampsNames())
timesChampWasBanned.columns = ['champ_name']
bannedChampsOcurrences = pd.DataFrame(allBannedChampsOcurrences())
bannedChampsOcurrences.columns = ['champ_name']

def getChampNumOfBans(champ):
  return bannedChampsOcurrences.loc[bannedChampsOcurrences['champ_name'] == champ].count()

numOfBans = timesChampWasBanned.apply(lambda row : getChampNumOfBans(row['champ_name']), axis = 1)
timesChampWasBanned.insert(1, 'n_bans',numOfBans, True)
top5BannedChamps = timesChampWasBanned.sort_values('n_bans',ascending=False).iloc[0:5]

eachWinRate = top5BannedChamps.apply(lambda row : winrate(row['champ_name']), axis = 1)
top5BannedChamps.insert(2, 'winrate',eachWinRate, True)

top5BannedChamps

"""É importante lembrar que os winrates dos campeões foram tirados depois dos jogos, ou seja, na escolha dos banimentos nas partidas profissionais muitos fatores eram considerados: afinidade do campeão com os jogadores inimigos, o quão forte um campeão era contra outro campeão da sua equipe, etc.

É possível ver que a maioria dos winrates dos campeões mais banidos varia para 50%. Será que realmente representa os campeões que tiveram maiores winrates? Antes de rodar algum algoritmo, para conferir, vamos encontrar o top 5 maiores winrates de todos campeões banidos:
"""

# top 5 winrate

allBannedChamps = pd.DataFrame(allBannedChampsNames())
allBannedChamps.columns = ['champ_name']
allBannedChampsWinrate = allBannedChamps.apply(lambda row : winrate(row['champ_name']), axis = 1)
allBannedChamps.insert(1, 'winrate',allBannedChampsWinrate, True)
top5WinrateBannedChamps = allBannedChamps.sort_values('winrate',ascending=False).iloc[0:5]
top5WinrateBannedChamps

top5WinrateChampsList = top5WinrateBannedChamps['champ_name'].tolist()
top5WinrateChampsList

"""Como é possível ver, nenhum campeão nos 5 maiores winrates está presente nos campeões mais banidos. Então, segue nossa hipótese nula a ser validada com uso de sklearn, aprendido na matéria.

## H0 = Os campeões mais banidos são aqueles com maiores winrates?
"""

from sklearn.model_selection import train_test_split

allBannedChamps

allBannedChampsOcurr = pd.DataFrame(allBannedChampsOcurrences())
allBannedChampsOcurr.columns = ['champ_name']
allBannedChampsOcurr['isTop5Banned'] = allBannedChampsOcurr['champ_name'].isin(top5WinrateBannedChamps)
allBannedChampsOcurr['winrate'] = allBannedChampsOcurr.apply(lambda row : winrate(row['champ_name']), axis = 1)
allBannedChampsOcurr

train_data, test_data = train_test_split(allBannedChampsOcurr, test_size = 0.2)

# se o resultado abaixo for baixo, rejeita hipotese nula
ss.ttest_1samp(train_data['winrate'], train_data.query('isTop5Banned == 1')['winrate'].mean())

"""Com o pvalue tão baixo, a hipótese nula é rejeitada e é possível ver que não há relação entre os campeões maiores winrates

# Classificador: checar se é campeão "roubado" ou não

Toda vez que entra um novo campeão no lol, muito se comenta é muito mais forte do que os outros já existentes. Com base nos winrates, esse classificador checa Nilah foi a última campeã adicionada, com atualmente um winrate de 49.84% nas partidas ranqueadas no maior elo (challenger), segundo o site de análises de League of Legends [lolalytics](https://lolalytics.com/lol/). O maior elo foi escolhido por ser o mais próximo para se comparar com partidas profissionais
"""

from sklearn.preprocessing import StandardScaler 
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report, confusion_matrix

# pegando dados para teste e treino

Y_train = train_data['isTop5Banned']
X_train = train_data.drop(['isTop5Banned', 'champ_name'], axis='columns')
Y_test = test_data['isTop5Banned']
X_test = test_data.drop(['isTop5Banned', 'champ_name'], axis='columns')

# utilizando knn neighbors pra classificação

scaler = StandardScaler()
scaler.fit(X_train)

classifier = KNeighborsClassifier(n_neighbors=5)
classifier.fit(X_train, Y_train) 

y_predict = classifier.predict(X_test)

print(classification_report(Y_test, y_predict))

newChamp= pd.DataFrame({'winrate':['0.56']})

y_predict = classifier.predict(newChamp)
y_predict

"""Como é possível ver, a nova campeã não foi classificada como uma das mais fortes do jogo.

Para fins de comparação, os winrates atuais dos top 5 foram pesquisados da mesma base (lolalytics).
"""

# insere winrates atuais dos top 5 campeões com maior winrate dessa base
top5WinrateBannedChamps.insert(2,'actual_winrate', [0.62, 0.59,0.57,0.61,0.49], True)

top5WinrateBannedChamps

def errorCalc(x,y):
  return str(abs((x-y)/x)*100) + '%'

top5WinrateBannedChamps['error'] = top5WinrateBannedChamps.apply(lambda x: errorCalc(x.actual_winrate, x.winrate), axis=1)
top5WinrateBannedChamps

"""Como conclusão dessa comparação, é possível ver que campeões mudam muito e que winrates dependem bastante da base a qual são retirados os dados"""